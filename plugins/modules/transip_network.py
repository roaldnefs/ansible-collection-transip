#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright: (c) 2022, Johan Kuijt <info@johankuijt.com>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
from __future__ import absolute_import, division, print_function

__metaclass__ = type


DOCUMENTATION = r'''
---
module: transip_network
short_description: Create or remove a TransIP network
description:
- Create or remove a TransIP network and add or remove vpses to or from it.
author: "Johan Kuijt (@yo-han)"
options:
  state:
    description:
    - Indicate desired state of the target.
    default: present
    choices: ['present', 'absent']
    type: str
  name:
    description:
    - The unique name of the network as provided by TransIP.
    type: str
  description:
    description:
    - The name of the network that can be set by the customer.
    type: str
  unique_description:
    description:
    - Require an unique description of the network. By default TransIP allows multiple networks with the
      same description. Setting this to "yes" allows only unique descriptions to be used. Useful for
      idempotence, as the unique name of the network will be generated by TransIP.
    default: False
    type: bool
  vps_name:
    description:
    - The unique name of the VPS as provided by TransIP.
    type: str
  end_time:
    description:
    - Indicate when the network will be terminated.
    - On 'end', the network will be terminated on the end date of the agreement.
    - On 'immediately', the network will be terminated immediately.
    default: end
    choices: ['end', 'immediately']
    type: str
extends_documentation_fragment:
- yo_han.transip.transip.documentation
'''

EXAMPLES = r'''
- name: Attach VPS to private network
  yo_han.transip.transip_network:
    state: present
    description: "my-network"
    unique_description: yes
    vps_name: "test-vps"
    access_token: REDACTED
  register: result

- name: Detach VPS from a private network
  yo_han.transip.transip_network:
    state: absent
    description: "my-network"
    unique_description: yes
    vps_name: "test-vps"
    access_token: REDACTED
'''

RETURN = r'''
data:
  description: All private networks
  returned: changed
  type: dict
  sample: [
    {
      "name": "test-privatenetwork",
      "description": "test private network",
      "isBlocked": false,
      "isLocked": false,
      "vpsNames": [
        "vps1",
        "vps2",
        "vps3"
      ]
    }
  ]
'''

from ansible_collections.yo_han.transip.plugins.module_utils.transip import TransIPHelper
from ansible.module_utils.basic import AnsibleModule
import traceback


class TransIPNetworkException(Exception):
    pass


class TransIPNetwork(object):

    def __init__(self, module):
        self.module = module
        self.rest = TransIPHelper(module)

    def list(self):
        """Returns a list of all Private Neworks."""
        path = "private-networks?pageSize=100"
        response = self.rest.get(path)

        if response.status_code == 200:
            return response.json.get("privateNetworks", [])

        return []

    def get(self):
        """Get information of a specific network."""
        name = self.module.params.get("name")
        description = self.module.params.get("description")
        unique_description = self.module.params.get("unique_description")

        json_data = self.get_by_name(name)
        if not json_data and unique_description:
            json_data = self.get_by_description(description)
        return json_data

    def get_by_name(self, name):
        """Get information of a specific network by name."""
        path = "private-networks/{0}".format(name)
        response = self.rest.get(path)

        if response.status_code == 200:
            return response.json

        return None

    def get_by_description(self, description):
        """Get information of a specific network by description."""
        for network in self.list():
            if network["description"] == description:
                return {"private-networks": network}
        return None

    def create(self):
        """Order a new network if it doesn't already exists."""
        json_data = self.get()
        if json_data:
            self.module.exit_json(changed=False)
        if self.module.check_mode:
            self.module.exit_json(changed=True)

        path = "private-networks?pageSize=100"

        data = {"description": self.module.params["description"]}

        response = self.rest.post(path, data=data)

        if response.status_code == 201:
            # Retrieve data about the newly created network, as the TransIP API
            # doesn't provide any information on the creation of the network
            json_data = self.get()
            # When using the demo access token, the API doesn't actually create
            # the network so the json_data might be empty
            network_data = {"privateNetwork": {}}
            if json_data and "privateNetwork" in json_data:
                network_data["privateNetwork"] = json_data["privateNetwork"]
            self.module.exit_json(changed=True, data=network_data)
        else:
            json_data = response.json
            error_msg = "Failed to order network"
            if json_data and "error" in json_data:
                error_msg = json_data["error"]
            self.module.fail_json(changed=False, msg=error_msg)

    def cancel(self):
        """Cancel a network using the specified end time attribute, on 'end' will
        terminate the network on the end date of the agreement while 'immediately'
        will terminate the network immediately.
        """
        name = self.module.params.get("name")
        end_time = self.module.params.get("end_time")

        json_data = self.get_by_name(name)
        if json_data:
            if self.module.check_mode:
                self.module.exit_json(change=True)
            path = "private-networks/{0}".format(name)
            data = {"endTime": end_time}
            response = self.rest.delete(path, data=data)

            if response.status_code == 204:
                self.module.exit_json(changed=True, msg="Network canceled")
            self.module.fail_json(
                changed=False, msg="Failed to cancel network")
        else:
            self.module.fail_json(changed=False, msg="Network not found")

    def vps(self, action):
        """Attach or detach a VPS to/from a private network."""
        json_data = self.get()

        if not json_data or "private-networks" not in json_data:
            self.module.fail_json(changed=False, msg="Network not found")

        networkName = json_data['private-networks']['name']

        path = "private-networks/{0}".format(networkName)
        data = {
            "vpsName": self.module.params["vps_name"],
            "action": action,
        }

        response = self.rest.patch(path, data=data)

        if response.status_code == 204:
            if action == "attachvps":
                self.module.exit_json(
                    changed=True, msg="VPS attached to network")
            elif action == "detachvps":
                self.module.exit_json(
                    changed=True, msg="VPS detached from network")
        else:
            self.module.fail_json(
                changed=False, msg="Failed to " + action + " VPS to network")

    def get_network(self):
        """Retrieve network information."""
        json_data = self.get()
        if json_data:
            self.module.exit_json(changed=True, data=json_data)
        else:
            self.module.fail_json(changed=True, msg="Network not found")


def handle_request(module):
    network = TransIPNetwork(module)
    state = module.params["state"]
    vps_name = module.params["vps_name"]
    name = module.params["name"]
    description = module.params["description"]

    if state and state == "present" and not vps_name:
        network.create()
    elif state and state == "absent" and not vps_name:
        network.cancel()
    elif state and state == "present" and vps_name:
        network.vps("attachvps")
    elif state and state == "absent" and vps_name:
        network.vps("detachvps")
    elif not state and (name or description):
        network.get_network()


def main():
    argument_spec = TransIPHelper.transip_argument_spec()
    argument_spec.update(
        state=dict(choices=["present", "absent"], default="present"),
        name=dict(type="str"),
        description=dict(type="str"),
        unique_description=dict(type="bool", default=False),
        vps_name=dict(type="str"),
        end_time=dict(choices=["end", "immediately"], default="end"),
    )

    module = AnsibleModule(
        argument_spec=argument_spec,
        required_if=([
            ("state", "present", ["description"]),
            ("state", "absent", ["end_time"]),
            ("unique_description", True, ["description"]),
        ]),
        supports_check_mode=True,
    )

    try:
        handle_request(module)
    except TransIPNetworkException as exc:
        module.fail_json(msg=str(exc), exception=traceback.format_exc())
    except KeyError as exc:
        module.fail_json(msg='Unable to load {0}'.format(
            str(exc)), exception=traceback.format_exc())


if __name__ == "__main__":
    main()
